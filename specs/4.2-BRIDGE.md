# 4.2 跨链桥 (Bridge) Spec

**版本**：v2.0
**状态**：设计完成
**最后更新**：2025-11-30
**关联文档**：[4.8-READ-FROM-ETL.md](./4.8-READ-FROM-ETL.md) (历史记录), [DEBUG_SUMMARY.md](../apps/contracts/DEBUG_SUMMARY.md) (调试总结)

---

## 1. 背景与动机

DripSwap Bridge 允许用户在 **Sepolia** 和 **Scroll Sepolia** 测试网之间无缝转移资产（vTokens）。为了提供最佳的用户体验和安全性，我们采用 **Chainlink CCIP** 作为底层跨链协议，并集成 **Uniswap Permit2** 以实现更高效的授权流程。

### 核心特性
1.  **双向互通**：支持 Sepolia <-> Scroll Sepolia 双向转账。
2.  **灵活付费**：用户可选择使用 **原生代币 (ETH)** 或 **LINK** 支付跨链 Gas 费。
3.  **Permit2 集成**：通过离线签名授权，优化 Approval 体验。
4.  **前端直连**：所有写操作由前端直接与链上合约交互，去中心化且安全。

---

## 2. 界面与交互设计 (UI/UX)

### 2.1 界面结构 ("Bridge assets" Card)

参考用户提供的设计稿，界面为一个居中的卡片组件，包含以下核心区域：

#### A. 网络选择 (Network Selection)
*   **From network**: 下拉菜单 (e.g., "Sepolia")。
*   **To network**: 下拉菜单 (e.g., "Scroll")。
*   *逻辑*：修改 "From" 时，"To" 自动切换为对应的对端链。

#### B. 资产选择 (Transfer Details)
*   **Token**: 下拉选择器 (展示 vETH, vUSDT, vUSDC, vDAI, vBTC, vLINK, vSCR)。
    *   *展示*：Token 图标 + Symbol。
    *   *余额*：在选择器下方显示当前链的余额 (e.g., "Balance: 100.00")。
*   **Amount**: 数值输入框。
    *   *功能*：提供 "Max" 按钮填充全部余额。

#### C. 费用支付偏好 (Fee Preference) - **新功能**
*   **Label**: "Pay fees in:"
*   **控件**: 单选框 (Radio) 或 切换开关 (Toggle)。
    *   🔘 **Native (ETH)**: 使用 ETH 支付 CCIP 费用（默认）。
    *   🔘 **LINK**: 使用 LINK 代币支付 CCIP 费用（通常更便宜）。
*   *实时估算*：在选项下方显示预估费用 (e.g., "~0.0002 ETH" 或 "~0.5 LINK")。

#### D. 操作按钮 (Action Button)
按钮状态根据当前上下文动态变化：
1.  **"Connect Wallet"**: 未连接钱包时。
2.  **"Switch Network"**: 钱包网络与 "From network" 不一致时。
3.  **"Approve [Token] to Permit2"**: 如果 Token 对 Permit2 合约的 Allowance 不足。
4.  **"Approve LINK to Permit2"**: (仅当选择 Pay in LINK 时) 如果 LINK 对 Permit2 合约的 Allowance 不足。
5.  **"Bridge"**: 一切就绪，点击发起交易（触发 Batch 签名）。

---

## 3. 功能需求 (User Stories)

### Story 1: 发起跨链转账 (Pay in LINK)

**角色**: 用户
**场景**: 将 100 vUSDT 从 Sepolia 跨链到 Scroll，使用 **LINK** 支付手续费。

**交互流程 (When-Case-Do)**:

**WHEN** 用户输入金额 "100" 并选择 "Pay in LINK"
- **前端动作**: 调用 `quoteFee(..., payInLink=true)` 获取预估费用。

**CASE A: 检查基础授权 (Max Approval Check)**
- **前端判断**:
  - `if (ERC20.allowance(user, Permit2) == 0)`:
    - **UI 显示**: "Approve [Token]" 按钮。
    - **Action**: 调用 `approve(Permit2, MaxUint256)`。
  - `else`:
    - **UI 显示**: 隐藏 Approve 按钮，直接显示 "Bridge"。
- *注：采用简化的 "Zero-Check" 策略，假设非零授权即为无限授权。*

**CASE B: 发起转账 (Buffered Batch Permit)**
- **用户操作**: 点击 "Bridge"。
- **前端动作**:
  1.  **构建 Batch Permit**:
      - Token: vUSDT, Amount: 100
      - Token: LINK, Amount: **Fee * 1.03** (预留 3% 缓冲)
      - Spender: Bridge Address
  2.  **发送交易**: 调用 `sendToken`，附带签名。

### Story 2: 发起跨链转账 (Pay in Native ETH)

**角色**: 用户
**场景**: 将 100 vUSDT 从 Sepolia 跨链到 Scroll，使用 **ETH** 支付手续费。

**交互流程**：

**CASE A: 检查基础授权**
- **逻辑**: 同上，检查 `if (vUSDT.allowance(user, Permit2) == 0)`。

**CASE B: 发起转账**
- **前端动作**:
  1.  **构建 Batch Permit**:
      - 仅包含 Token: vUSDT, Amount: 100
  2.  **计算 Value**:
      - **Msg.Value** = `(quoteFee * 1.03) + serviceFee`
      - *注意：Buffer 仅应用于变动的 CCIP 费用部分，固定服务费无需 Buffer。*
  3.  **发送交易**: 调用 `sendToken{value: Msg.Value}`。

---

## 4. 技术方案与实现细节

### 4.1 核心合约交互 (更新版)

(保持不变)

### 4.2 Permit2 Batch 签名流程

(保持不变)

### 4.3 环境配置 (Config)
(保持不变)

### 4.4 参考实现代码 (sign-permit2.js)

以下是 `tools/sign-permit2.js` 的完整逻辑，供前端开发参考如何构建 EIP-712 数据：

```javascript
import { ethers } from "ethers";

// 1. 配置
const PERMIT2_ADDRESS = "0x000000000022D473030F116dDEE9F6B43aC78BA3";
const BRIDGE_ADDRESS = "0x..."; // 当前网络的 Bridge 合约地址

// 2. 准备数据
async function buildPermitSignature(signer, chainId, tokenAddress, tokenAmount, linkAddress, linkAmount, useLink) {
    
    const domain = {
        name: "Permit2",
        chainId: Number(chainId),
        verifyingContract: PERMIT2_ADDRESS,
    };

    const types = {
        TokenPermissions: [
            { name: "token", type: "address" },
            { name: "amount", type: "uint256" },
        ],
        PermitBatchTransferFrom: [
            { name: "permitted", type: "TokenPermissions[]" },
            { name: "spender", type: "address" },
            { name: "nonce", type: "uint256" },
            { name: "deadline", type: "uint256" },
        ],
    };

    // 构造 permitted 数组
    const permitted = [];
    // 1. 添加跨链 Token
    permitted.push({ token: tokenAddress, amount: tokenAmount });
    
    // 2. 如果使用 LINK 支付，添加 LINK
    if (useLink) {
        permitted.push({ token: linkAddress, amount: linkAmount });
    }

    const message = {
        permitted,
        spender: BRIDGE_ADDRESS, // Spender 必须是 Bridge 合约
        nonce: Math.floor(Math.random() * 1e12), // 随机 Nonce
        deadline: Math.floor(Date.now() / 1000) + 3600, // 1小时有效
    };

    // 3. 签名
    const signature = await signer.signTypedData(domain, types, message);

    return {
        permit: message,
        signature
    };
}

### 4.5 关键业务逻辑补充

#### A. 费用缓冲策略 (Fee Buffer)

由于 CCIP 费用随网络拥堵动态波动，必须预留 3% 缓冲。不同支付方式的处理逻辑如下：

1.  **Pay in LINK (用户无损)**:
    *   **签名**: Permit2 签名金额 = `quotedFee * 1.03`。
    *   **执行**: Bridge 合约计算实时费用，仅通过 Permit2 拉取实际所需金额 (`ccipFee`)。
    *   **结果**: 剩余的 3% Buffer **保留在用户钱包中**，不会被扣除。

2.  **Pay in Native ETH (多余部分归 Admin)**:
    *   **支付**: `msg.value` = `(quotedFee * 1.03) + serviceFee`。
    *   **执行**: Bridge 合约扣除实时 `ccipFee` 给 Router。
    *   **剩余处理**: 代码逻辑 `collectorAmount = msg.value - ccipFee`。
    *   **结果**: **多余的 ETH Buffer 会被转给 `feeCollector` (Admin 地址)，不会退还给用户。**
    *   *设计建议*: 前端应在 UI 提示用户 "Max fee includes a small buffer to ensure success"，并接受这点损耗作为交易成功的保障。

#### B. 无限授权策略 (Infinite Approval)

为了优化用户体验，减少签名次数，采用以下策略：
*   **判断**: 当 `allowance == 0` 时，触发授权流程。
*   **授权**: 调用 `token.approve(Permit2, MaxUint256)`。
*   **优势**: 简化判断逻辑，假设用户只要授权过即为无限授权。

---

## 5. 任务清单 (Checklist)

### 5.1 前端开发 (apps/frontend)
- [ ] **Config**: 建立 `CCIP_CHAINS` 和 `TOKEN_LIST` 常量表。
- [ ] **Hooks**: 实现 `useBridgeQuote`，并增加 **3% Buffer** 逻辑。
- [ ] **Hooks**: 实现 `usePermit2Sign`，支持 Batch 结构和金额缓冲。
- [ ] **Hooks**: 实现 `useApprove`，默认使用 **MaxUint256**。
- [ ] **UI**: 开发 Bridge Card 组件。
- [ ] **Integration**: 联调 `bridgeToken`，处理 `msg.value` 计算。

### 5.2 验证与测试
- [ ] **Permit2**: 验证签名在链上能否被 `SignatureTransfer` 正确恢复。
- [ ] **Fee**: 验证 Native 和 LINK 两种支付方式是否扣除正确余额。
- [ ] **E2E**: 完成一次从 Sepolia 到 Scroll 的完整闭环测试。

---

## 6. 读操作与历史记录

> **注意**: 本文档仅包含前端写操作交互。
> 所有的历史记录查询（如 "My Bridge History"）、状态轮询逻辑，请参考 **[4.8-READ-FROM-ETL.md](./4.8-READ-FROM-ETL.md)**。
> 前端应调用 BFF 提供的 GraphQL 接口 `bridgeHistory` 来获取跨链状态。
